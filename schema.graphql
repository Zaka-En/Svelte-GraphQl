type AuthorConnection {
  edges: [AuthorTypeEdge!]!
  pageInfo: CustomPageInfo!
}

type AuthorType implements Node {
  biography: String
  books: [BookType!]!
  country: String!
  fullname: String

  """The Globally Unique ID of this object"""
  id: ID!
  name: String!
}

"""An edge in a connection."""
type AuthorTypeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: AuthorType!
}

type BookType {
  author: AuthorType
  authorId: Int!
  id: Int!
  isbn: String!
  pages: Int!
  publicationYear: Int!
  title: String!
}

input CreateAuthorInput {
  biography: String = null
  country: String!
  fullname: String = null
  name: String!
}

input CreateBookInput {
  authorId: Int!
  isbn: String!
  pages: Int!
  publicationYear: Int!
  title: String!
}

type CustomPageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
  totalCount: Int!
}

"""Date with time (isoformat)"""
scalar DateTime

input FinishReadingInput {
  id: Int!
}

input LoginInput {
  email: String!
  password: String!
}

type LoginResponse {
  accessToken: String!
  refreshToken: String!
  tokenType: String!
  user: UserType
}

type Mutation {
  addRating(text: String!): String!
  createAuthor(input: CreateAuthorInput!): AuthorType!
  createBook(input: CreateBookInput!): BookType!
  deleteAuthor(id: Int!): Boolean!
  deleteBook(id: Int!): Boolean!
  finishReading(input: FinishReadingInput!): ReadingStateType!
  generateReporting(authorId: Int!): String!
  login(data: LoginInput!): LoginResponse!
  registerUser(data: RegisterInput!): UserType!
  sendBookChatMessage(bookId: Int!, message: String!, userName: String!): Boolean!
  startReading(input: StartReadingInput!): ReadingStateType!
  updateAuthor(input: UpdateAuthorInput!): AuthorType!
  updateBook(input: UpdateBookInput!): BookType!
  updateProgress(input: UpdateProgressInput!): ReadingStateType!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  id: ID!
}

type Query {
  author(id: Int!): AuthorType
  authors(after: String = null, first: Int = null): AuthorConnection!
  authorsQuery: [AuthorType!]!
  book(id: Int!): BookType
  books: [BookType!]!
  myReadingProgress(userId: Int!): [ReadingStateType!]!
  recomendations(user: String!): [String!]!
  userInfo(userId: Int!): UserProfileType!
}

type ReadingStateType {
  book: BookType
  bookId: Int!
  currentPage: Int!
  finishDate: DateTime
  id: Int!
  startDate: DateTime!
}

input RegisterInput {
  email: String!
  fullname: String = null
  name: String!
  password: String!
  rol: String! = "user"
}

input StartReadingInput {
  bookId: Int!
  userId: Int!
}

type Subscription {
  bookChat(bookId: Int!): String!
  bookRatings: String!
  updateAuthorNotifications: String!
}

input UpdateAuthorInput {
  biography: String
  country: String
  fullname: String
  id: Int!
  name: String
}

input UpdateBookInput {
  authorId: Int
  id: Int!
  isbn: String
  pages: Int
  publicationYear: Int
  title: String
}

input UpdateProgressInput {
  currentPage: Int!
  id: Int!
}

type UserProfileType {
  about: String
  city: String
  email: String!
  fullname: String
  id: ID!
  name: String!
  province: String
  rol: String!
  secondName: String
  streetAdress: String
  zipCode: String
}

type UserType {
  email: String!
  fullname: String
  id: ID!
  name: String!
  rol: String!
}